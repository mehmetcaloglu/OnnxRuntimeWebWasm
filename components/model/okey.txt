import React, { useState, useEffect } from 'react';
import ndarray from 'ndarray';
import ops from 'ndarray-ops';
import WebcamModelUI from '../common/WebcamModelUI';
import { runModelUtils, yolo, yoloTransforms } from "../../utils/index";
import { Tensor, InferenceSession } from 'onnxruntime-web';

const MODEL_FILEPATH_PROD = `/onnxruntime-web-demo/yolo.onnx`;
const MODEL_FILEPATH_DEV = '/yolo.onnx';

const Yolo = ({ hasWebGL }) => {
  const [modelFilepath, setModelFilepath] = useState(
    process.env.NODE_ENV === 'production' ? MODEL_FILEPATH_PROD : MODEL_FILEPATH_DEV
  );

  const warmupModel = (session) => {
    debugger
    return runModelUtils.warmupModel(session, [1, 3, 416, 416]);
  };

  const preprocess = (ctx) => {
    console.log('preprocess');
    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    const { data, width, height } = imageData;
    const dataTensor = ndarray(new Float32Array(data), [width, height, 4]);
    const dataProcessedTensor = ndarray(new Float32Array(width * height * 3), [1, 3, width, height]);

    ops.assign(dataProcessedTensor.pick(0, 0, null, null), dataTensor.pick(null, null, 0));
    ops.assign(dataProcessedTensor.pick(0, 1, null, null), dataTensor.pick(null, null, 1));
    ops.assign(dataProcessedTensor.pick(0, 2, null, null), dataTensor.pick(null, null, 2));

    const tensor = new Tensor('float32', new Float32Array(width * height * 3), [1, 3, width, height]);
    tensor.data.set(dataProcessedTensor.data);
    return tensor;
  };

  const postprocess = async (tensor, inferenceTime) => {
    console.log('postprocess');
    try {
      const originalOutput = new Tensor('float32', tensor.data, [1, 125, 13, 13]);
      const outputTensor = yoloTransforms.transpose(originalOutput, [0, 2, 3, 1]);

      const boxes = await yolo.postprocess(outputTensor, 20);
      boxes.forEach((box) => {
        const { top, left, bottom, right, classProb, className } = box;
        drawRect(left, top, right - left, bottom - top, `${className} Confidence: ${Math.round(classProb * 100)}% Time: ${inferenceTime.toFixed(1)}ms`);
      });
    } catch (e) {
      alert('Model is not valid!');
    }
  };

  const drawRect = (x, y, w, h, text = '', color = 'red') => {
    console.log('drawRect');
    const webcamContainerElement = document.getElementById('webcam-container');
    const [ox, oy] = [(webcamContainerElement.offsetWidth - 416) / 2, (webcamContainerElement.offsetHeight - 416) / 2];
    const rect = document.createElement('div');
    rect.style.cssText = `top: ${y + oy}px; left: ${x + ox}px; width: ${w}px; height: ${h}px; border-color: ${color};`;
    const label = document.createElement('div');
    label.innerText = text;
    rect.appendChild(label);
    webcamContainerElement.appendChild(rect);
  };

  return (
    <WebcamModelUI
      modelName="Yolo"
      hasWebGL={hasWebGL}
      modelFilepath={modelFilepath}
      imageSize={416}
      warmupModel={warmupModel}
      preprocess={preprocess}
      postprocess={postprocess}
    />
  );
};

export default Yolo;
